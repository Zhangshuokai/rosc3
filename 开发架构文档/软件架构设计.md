# 建筑喷涂施工机器人软件架构设计

## 文档信息

| 项目 | 内容 |
|------|------|
| **文档标题** | 软件架构设计文档 |
| **文档版本** | v1.0.0 |
| **编制日期** | 2025-10-23 |
| **软件框架** | ESP-IDF + FreeRTOS + Micro-ROS |
| **编程语言** | C (C11标准) |
| **目标平台** | ESP32-C3 RISC-V 160MHz |

---

## 目录

- [1. 软件架构概述](#1-软件架构概述)
- [2. 分层架构设计](#2-分层架构设计)
- [3. 模块设计](#3-模块设计)
- [4. 任务与线程设计](#4-任务与线程设计)
- [5. 数据流设计](#5-数据流设计)
- [6. 状态机设计](#6-状态机设计)
- [7. 驱动层设计](#7-驱动层设计)
- [8. 通信层设计](#8-通信层设计)

---

## 1. 软件架构概述

### 1.1 架构风格

本系统采用**分层架构**（Layered Architecture）+ **组件化设计**（Component-Based Design）：

```
┌─────────────────────────────────────────────────────────────┐
│                     应用层 (Application Layer)               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  节点逻辑    │  │  状态机      │  │  UI显示      │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
├─────────────────────────────────────────────────────────────┤
│                     服务层 (Service Layer)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  ROS通信     │  │  配置管理    │  │  诊断服务    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
├─────────────────────────────────────────────────────────────┤
│                     驱动层 (Driver Layer)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  传感器驱动  │  │  执行器驱动  │  │  通信驱动    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
├─────────────────────────────────────────────────────────────┤
│                     硬件抽象层 (HAL Layer)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  I2C HAL     │  │  ADC HAL     │  │  PWM HAL     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
├─────────────────────────────────────────────────────────────┤
│                ESP-IDF + FreeRTOS (OS Layer)                 │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 设计原则

| 原则 | 说明 | 实现方式 |
|------|------|---------|
| **单一职责** | 每个模块只负责一项功能 | 模块化设计 |
| **开闭原则** | 对扩展开放，对修改封闭 | 接口抽象 |
| **依赖倒置** | 高层不依赖低层，都依赖抽象 | HAL层抽象 |
| **接口隔离** | 使用多个专门接口，不使用单一总接口 | 最小接口设计 |
| **最小知识** | 模块间低耦合 | 清晰的接口边界 |

---

## 2. 分层架构设计

### 2.1 应用层（Application Layer）

**职责**：实现具体的业务逻辑

```c
// 应用层主循环示例（以底盘节点为例）
void chassis_application_main(void) {
    // 初始化
    chassis_init();
    ros_comm_init(&ros_config);
    oled_display_init(&oled_ctx);
    
    // 主循环
    while (1) {
        // 1. 读取编码器
        chassis_update_odometry();
        
        // 2. 执行PID控制
        chassis_pid_control();
        
        // 3. 发布里程计
        chassis_publish_odom();
        
        // 4. 更新OLED显示
        oled_update_status();
        
        // 5. ROS spin处理回调
        ros_comm_spin_once(10);
        
        vTaskDelay(pdMS_TO_TICKS(20)); // 50Hz
    }
}
```

### 2.2 服务层（Service Layer）

**职责**：提供通用服务，供应用层调用

#### ROS通信服务

```c
// ROS服务初始化
esp_err_t ros_comm_init(const ros_config_t *config) {
    // 创建Micro-ROS支持
    rcl_allocator_t allocator = rcl_get_default_allocator();
    rclc_support_t support;
    
    // 创建节点
    rcl_node_t node;
    rclc_node_init_default(&node, config->node_name, 
                           config->namespace, &support);
    
    return ESP_OK;
}
```

#### 配置管理服务

```c
// 配置服务：NVS优先，否则使用sdkconfig
esp_err_t config_load(config_service_t *cfg) {
    // 1. 尝试从NVS加载
    esp_err_t err = nvs_get_str(cfg->nvs_handle, "wifi_ssid", 
                                cfg->config.wifi_ssid, &len);
    if (err == ESP_OK) {
        return ESP_OK; // NVS有效，使用NVS配置
    }
    
    // 2. NVS无效，使用sdkconfig默认值
    strncpy(cfg->config.wifi_ssid, CONFIG_WIFI_SSID, 32);
    strncpy(cfg->config.wifi_password, CONFIG_WIFI_PASSWORD, 64);
    
    return ESP_OK;
}
```

---

## 3. 模块设计

### 3.1 节点专用模块

#### 3.1.1 底盘控制模块（NODE-01）

```c
/**
 * @file chassis_control.c
 * @brief 差速底盘控制模块
 */

// 底盘状态
typedef struct {
    float x, y, theta;          // 位置和姿态
    float v_linear, v_angular;  // 速度
    uint32_t encoder_left, encoder_right;
    float pid_output_left, pid_output_right;
} chassis_state_t;

// PID控制器
typedef struct {
    float kp, ki, kd;
    float error, error_sum, error_last;
    float output;
} pid_controller_t;

// 初始化底盘
esp_err_t chassis_init(void) {
    // 初始化电机驱动
    motor_driver_init();
    
    // 初始化编码器（I2C读取）
    encoder_init();
    
    // 初始化PID控制器
    pid_init(&pid_left, KP, KI, KD);
    pid_init(&pid_right, KP, KI, KD);
    
    return ESP_OK;
}

// 里程计更新（50Hz调用）
void chassis_update_odometry(void) {
    // 读取编码器
    uint32_t enc_l = encoder_read_left();
    uint32_t enc_r = encoder_read_right();
    
    // 计算增量
    int32_t delta_l = enc_l - state.encoder_left;
    int32_t delta_r = enc_r - state.encoder_right;
    
    // 更新里程计
    float dist_l = delta_l * WHEEL_CIRCUMFERENCE / ENCODER_PPR;
    float dist_r = delta_r * WHEEL_CIRCUMFERENCE / ENCODER_PPR;
    
    float dist_center = (dist_l + dist_r) / 2.0f;
    float delta_theta = (dist_r - dist_l) / WHEEL_BASE;
    
    state.x += dist_center * cos(state.theta);
    state.y += dist_center * sin(state.theta);
    state.theta += delta_theta;
    
    // 更新编码器值
    state.encoder_left = enc_l;
    state.encoder_right = enc_r;
}

// PID速度控制
void chassis_pid_control(void) {
    // 计算目标轮速
    float target_v_left = cmd.v_linear - cmd.v_angular * WHEEL_BASE / 2;
    float target_v_right = cmd.v_linear + cmd.v_angular * WHEEL_BASE / 2;
    
    // 计算当前轮速（从编码器）
    float current_v_left = calculate_wheel_velocity_left();
    float current_v_right = calculate_wheel_velocity_right();
    
    // PID控制
    float pwm_left = pid_compute(&pid_left, target_v_left, current_v_left);
    float pwm_right = pid_compute(&pid_right, target_v_right, current_v_right);
    
    // 设置电机PWM
    motor_set_pwm(MOTOR_LEFT, pwm_left);
    motor_set_pwm(MOTOR_RIGHT, pwm_right);
}
```

#### 3.1.2 升降机构模块（NODE-02）

```c
/**
 * @file lift_control.c
 * @brief 升降机构控制模块
 */

typedef struct {
    float current_height;    // 当前高度(m)
    float target_height;     // 目标高度(m)
    float velocity;          // 速度(m/s)
    bool upper_limit;        // 上限位
    bool lower_limit;        // 下限位
    uint16_t encoder_angle;  // AS5600角度(0-4095)
} lift_state_t;

// 初始化升降机构
esp_err_t lift_init(void) {
    // 初始化伺服电机
    servo_init(GPIO_NUM_0);
    
    // 初始化AS5600磁编码器(I2C)
    as5600_init();
    
    // 初始化限位开关
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << GPIO_LIMIT_UPPER) | (1ULL << GPIO_LIMIT_LOWER),
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = GPIO_PULLUP_ENABLE,
        .intr_type = GPIO_INTR_NEGEDGE
    };
    gpio_config(&io_conf);
    
    return ESP_OK;
}

// 位置控制（20Hz调用）
void lift_position_control(void) {
    // 检查限位
    bool upper = !gpio_get_level(GPIO_LIMIT_UPPER);
    bool lower = !gpio_get_level(GPIO_LIMIT_LOWER);
    
    if (upper || lower) {
        servo_stop();
        return;
    }
    
    // 读取编码器位置
    uint16_t angle = as5600_read_angle();
    float current_height = angle_to_height(angle);
    
    // 位置控制
    float error = state.target_height - current_height;
    
    if (fabs(error) < 0.005) { // 5mm死区
        servo_stop();
    } else {
        float velocity = pid_compute(&pid_lift, error);
        servo_set_velocity(velocity);
    }
}
```

#### 3.1.3 环境监测模块（NODE-03）

```c
/**
 * @file environment_monitor.c
 * @brief 环境监测模块
 */

typedef struct {
    float temperature;  // °C
    float humidity;     // %
    float pressure;     // Pa
    bool is_suitable;   // 施工适宜性
} environment_data_t;

// 初始化BME280传感器
esp_err_t environment_init(void) {
    bme280_config_t config = {
        .i2c_addr = BME280_I2C_ADDR,
        .mode = BME280_MODE_NORMAL,
        .filter = BME280_FILTER_COEFF_4,
        .standby_time = BME280_STANDBY_MS_500
    };
    
    return bme280_init(&config);
}

// 读取环境数据（0.5Hz调用）
void environment_read_sensors(environment_data_t *data) {
    // 读取BME280
    bme280_read_all(&data->temperature, &data->pressure, &data->humidity);
    
    // 判断施工适宜性
    data->is_suitable = 
        (data->temperature >= 5.0 && data->temperature <= 35.0) &&
        (data->humidity >= 40.0 && data->humidity <= 85.0);
}
```

---

## 4. 任务与线程设计

### 4.1 FreeRTOS任务架构

```c
// 任务优先级定义
#define TASK_PRIORITY_WIFI          20  // WiFi任务（系统）
#define TASK_PRIORITY_ROS           15  // ROS通信任务
#define TASK_PRIORITY_CONTROL       10  // 控制任务
#define TASK_PRIORITY_SENSOR        5   // 传感器任务
#define TASK_PRIORITY_DIAGNOSTIC    3   // 诊断任务
#define TASK_PRIORITY_GUI           1   // GUI任务

// 任务栈大小定义
#define STACK_SIZE_WIFI             4096
#define STACK_SIZE_ROS              8192
#define STACK_SIZE_CONTROL          4096
#define STACK_SIZE_SENSOR           3072
#define STACK_SIZE_DIAGNOSTIC       2048
#define STACK_SIZE_GUI              4096
```

### 4.2 典型节点任务配置（以底盘节点为例）

```c
void app_main(void) {
    // 1. 初始化WiFi
    wifi_manager_init(&wifi_config);
    wifi_manager_connect();
    
    // 2. 创建ROS通信任务
    xTaskCreate(
        ros_comm_task,           // 任务函数
        "ros_comm",              // 任务名称
        STACK_SIZE_ROS,          // 栈大小
        NULL,                    // 参数
        TASK_PRIORITY_ROS,       // 优先级
        &ros_task_handle         // 任务句柄
    );
    
    // 3. 创建控制任务
    xTaskCreate(
        chassis_control_task,
        "chassis_ctrl",
        STACK_SIZE_CONTROL,
        NULL,
        TASK_PRIORITY_CONTROL,
        &control_task_handle
    );
    
    // 4. 创建传感器任务
    xTaskCreate(
        sensor_read_task,
        "sensor",
        STACK_SIZE_SENSOR,
        NULL,
        TASK_PRIORITY_SENSOR,
        &sensor_task_handle
    );
    
    // 5. 创建GUI任务
    xTaskCreate(
        gui_update_task,
        "gui",
        STACK_SIZE_GUI,
        NULL,
        TASK_PRIORITY_GUI,
        &gui_task_handle
    );
}
```

### 4.3 任务间通信

#### 队列（Queue）

```c
// 传感器数据队列
QueueHandle_t sensor_data_queue;

// 创建队列
sensor_data_queue = xQueueCreate(10, sizeof(sensor_data_t));

// 生产者（传感器任务）
sensor_data_t data;
read_sensor(&data);
xQueueSend(sensor_data_queue, &data, portMAX_DELAY);

// 消费者（ROS任务）
sensor_data_t data;
if (xQueueReceive(sensor_data_queue, &data, 100 / portTICK_PERIOD_MS)) {
    publish_to_ros(&data);
}
```

#### 互斥锁（Mutex）

```c
// 保护共享资源
SemaphoreHandle_t state_mutex;

// 创建互斥锁
state_mutex = xSemaphoreCreateMutex();

// 访问共享状态
xSemaphoreTake(state_mutex, portMAX_DELAY);
update_shared_state();
xSemaphoreGive(state_mutex);
```

#### 事件组（Event Group）

```c
// 系统事件
EventGroupHandle_t system_events;

#define EVENT_WIFI_CONNECTED    (1 << 0)
#define EVENT_ROS_READY         (1 << 1)
#define EVENT_SENSOR_READY      (1 << 2)

// 等待所有初始化完成
EventBits_t bits = xEventGroupWaitBits(
    system_events,
    EVENT_WIFI_CONNECTED | EVENT_ROS_READY | EVENT_SENSOR_READY,
    pdFALSE,
    pdTRUE,  // 等待所有位
    portMAX_DELAY
);
```

---

## 5. 数据流设计

### 5.1 传感器数据流

```
┌─────────────┐
│  硬件传感器 │
└──────┬──────┘
       │ 定时器触发
       ▼
┌──────────────────┐
│  传感器驱动层    │ ← I2C/ADC读取
│  - BME280        │
│  - MPU6050       │
│  - AS5600        │
└──────┬───────────┘
       │ 原始数据
       ▼
┌──────────────────┐
│  数据处理层      │
│  - 滤波          │
│  - 校准          │
│  - 单位转换      │
└──────┬───────────┘
       │ 处理后数据
       ▼
┌──────────────────┐
│  ROS消息封装     │
│  - 填充Header    │
│  - 时间戳        │
│  - 序列号        │
└──────┬───────────┘
       │ ROS消息
       ▼
┌──────────────────┐
│  ROS发布         │
│  - Publish       │
│  - QoS应用       │
└──────────────────┘
```

### 5.2 控制指令流

```
┌──────────────────┐
│  ROS订阅         │
│  - cmd_vel       │
│  - cmd_position  │
└──────┬───────────┘
       │ ROS消息
       ▼
┌──────────────────┐
│  消息解析        │
│  - 类型检查      │
│  - 范围检查      │
│  - 安全检查      │
└──────┬───────────┘
       │ 控制指令
       ▼
┌──────────────────┐
│  控制算法        │
│  - PID控制       │
│  - 轨迹规划      │
│  - 限幅保护      │
└──────┬───────────┘
       │ 执行器指令
       ▼
┌──────────────────┐
│  执行器驱动      │
│  - PWM输出       │
│  - 电机控制      │
└──────────────────┘
```

---

## 6. 状态机设计

### 6.1 节点生命周期状态机

```c
typedef enum {
    NODE_STATE_INIT,          // 初始化
    NODE_STATE_WIFI_CONNECTING, // WiFi连接中
    NODE_STATE_WIFI_CONNECTED,  // WiFi已连接
    NODE_STATE_ROS_CONNECTING,  // ROS Agent连接中
    NODE_STATE_RUNNING,         // 正常运行
    NODE_STATE_ERROR,           // 错误状态
    NODE_STATE_RECOVERY         // 恢复中
} node_state_t;

// 状态机处理
void node_state_machine_update(void) {
    switch (current_state) {
        case NODE_STATE_INIT:
            if (hw_init_success()) {
                current_state = NODE_STATE_WIFI_CONNECTING;
            }
            break;
            
        case NODE_STATE_WIFI_CONNECTING:
            if (wifi_connected()) {
                current_state = NODE_STATE_WIFI_CONNECTED;
            } else if (wifi_retry_exceeded()) {
                current_state = NODE_STATE_ERROR;
            }
            break;
            
        case NODE_STATE_WIFI_CONNECTED:
            if (ros_agent_connect_success()) {
                current_state = NODE_STATE_RUNNING;
            }
            break;
            
        case NODE_STATE_RUNNING:
            if (wifi_disconnected()) {
                current_state = NODE_STATE_ERROR;
            }
            // 正常运行逻辑
            break;
            
        case NODE_STATE_ERROR:
            // 尝试恢复
            current_state = NODE_STATE_RECOVERY;
            break;
            
        case NODE_STATE_RECOVERY:
            if (recovery_success()) {
                current_state = NODE_STATE_WIFI_CONNECTING;
            }
            break;
    }
}
```

### 6.2 执行器状态机（以升降机构为例）

```c
typedef enum {
    LIFT_STATE_IDLE,       // 空闲
    LIFT_STATE_MOVING_UP,  // 上升中
    LIFT_STATE_MOVING_DOWN,// 下降中
    LIFT_STATE_HOMING,     // 归零中
    LIFT_STATE_ERROR       // 错误
} lift_state_t;

void lift_state_machine_update(void) {
    switch (lift_state) {
        case LIFT_STATE_IDLE:
            if (new_target_received()) {
                if (target_height > current_height) {
                    lift_state = LIFT_STATE_MOVING_UP;
                } else {
                    lift_state = LIFT_STATE_MOVING_DOWN;
                }
            } else if (home_cmd_received()) {
                lift_state = LIFT_STATE_HOMING;
            }
            break;
            
        case LIFT_STATE_MOVING_UP:
            if (upper_limit_triggered()) {
                lift_state = LIFT_STATE_ERROR;
            } else if (target_reached()) {
                lift_state = LIFT_STATE_IDLE;
            }
            break;
            
        case LIFT_STATE_MOVING_DOWN:
            if (lower_limit_triggered()) {
                lift_state = LIFT_STATE_ERROR;
            } else if (target_reached()) {
                lift_state = LIFT_STATE_IDLE;
            }
            break;
            
        case LIFT_STATE_HOMING:
            if (lower_limit_triggered()) {
                reset_position_to_zero();
                lift_state = LIFT_STATE_IDLE;
            }
            break;
            
        case LIFT_STATE_ERROR:
            servo_stop();
            publish_error();
            break;
    }
}
```

---

## 7. 驱动层设计

### 7.1 传感器驱动接口标准化

```c
/**
 * @file sensor_interface.h
 * @brief 通用传感器驱动接口
 */

// 传感器驱动接口
typedef struct {
    const char *name;
    esp_err_t (*init)(void *config);
    esp_err_t (*read)(void *data);
    esp_err_t (*calibrate)(void *params);
    esp_err_t (*deinit)(void);
} sensor_driver_t;

// 具体驱动实现示例：BME280
static esp_err_t bme280_init(void *config) {
    bme280_config_t *cfg = (bme280_config_t *)config;
    // 初始化I2C通信
    // 配置BME280寄存器
    return ESP_OK;
}

static esp_err_t bme280_read(void *data) {
    environment_data_t *env = (environment_data_t *)data;
    // 读取温湿度气压
    return ESP_OK;
}

// 注册驱动
const sensor_driver_t bme280_driver = {
    .name = "BME280",
    .init = bme280_init,
    .read = bme280_read,
    .calibrate = bme280_calibrate,
    .deinit = bme280_deinit
};
```

### 7.2 执行器驱动接口标准化

```c
/**
 * @file actuator_interface.h
 * @brief 通用执行器驱动接口
 */

// 执行器驱动接口
typedef struct {
    const char *name;
    esp_err_t (*init)(void *config);
    esp_err_t (*set_output)(float value);
    esp_err_t (*get_feedback)(float *value);
    esp_err_t (*stop)(void);
    esp_err_t (*deinit)(void);
} actuator_driver_t;

// 具体驱动实现示例：PWM电机
static esp_err_t pwm_motor_set_output(float value) {
    // value: -1.0 ~ 1.0
    uint32_t duty = (uint32_t)((fabs(value) * PWM_MAX_DUTY));
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
    return ESP_OK;
}

const actuator_driver_t pwm_motor_driver = {
    .name = "PWM Motor",
    .init = pwm_motor_init,
    .set_output = pwm_motor_set_output,
    .get_feedback = pwm_motor_get_feedback,
    .stop = pwm_motor_stop,
    .deinit = pwm_motor_deinit
};
```

---

## 8. 通信层设计

### 8.1 Micro-ROS集成架构

```c
/**
 * @file micro_ros_integration.c
 * @brief Micro-ROS集成层
 */

// Micro-ROS上下文
typedef struct {
    rcl_node_t node;
    rcl_executor_t executor;
    rclc_support_t support;
    
    // 发布者
    rcl_publisher_t *publishers;
    size_t publisher_count;
    
    // 订阅者
    rcl_subscription_t *subscriptions;
    size_t subscription_count;
    
    // 服务
    rcl_service_t *services;
    size_t service_count;
} micro_ros_context_t;

// 初始化Micro-ROS
esp_err_t micro_ros_init(micro_ros_context_t *ctx, 
                         const char *node_name) {
    // 1. 配置传输层（UDP）
    rmw_uros_set_custom_transport(
        true,
        NULL,
        custom_transport_open,
        custom_transport_close,
        custom_transport_write,
        custom_transport_read
    );
    
    // 2. 创建支持结构
    rcl_allocator_t allocator = rcl_get_default_allocator();
    rclc_support_init(&ctx->support, 0, NULL, &allocator);
    
    // 3. 创建节点
    rclc_node_init_default(&ctx->node, node_name, "", &ctx->support);
    
    // 4. 创建执行器
    rclc_executor_init(&ctx->executor, &ctx->support.context, 
                       EXECUTOR_HANDLES, &allocator);
    
    return ESP_OK;
}

// Spin循环
void micro_ros_spin_task(void *pvParameters) {
    micro_ros_context_t *ctx = (micro_ros_context_t *)pvParameters;
    
    while (1) {
        rclc_executor_spin_some(&ctx->executor, RCL_MS_TO_NS(10));
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}
```

### 8.2 自定义UDP传输层

```c
/**
 * @file micro_ros_transport.c
 * @brief Micro-ROS UDP传输层实现
 */

// UDP套接字
static int udp_socket = -1;
static struct sockaddr_in agent_addr;

// 打开传输
bool custom_transport_open(struct uxrCustomTransport *transport) {
    // 创建UDP套接字
    udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (udp_socket < 0) {
        return false;
    }
    
    // 配置Agent地址
    agent_addr.sin_family = AF_INET;
    agent_addr.sin_port = htons(CONFIG_MICRO_ROS_AGENT_PORT);
    inet_pton(AF_INET, CONFIG_MICRO_ROS_AGENT_IP, 
              &agent_addr.sin_addr);
    
    return true;
}

// 发送数据
size_t custom_transport_write(
    struct uxrCustomTransport *transport,
    const uint8_t *buf,
    size_t len,
    uint8_t *err
) {
    int sent = sendto(udp_socket, buf, len, 0,
                      (struct sockaddr *)&agent_addr,
                      sizeof(agent_addr));
    return (sent > 0) ? sent : 0;
}

// 接收数据
size_t custom_transport_read(
    struct uxrCustomTransport *transport,
    uint8_t *buf,
    size_t len,
    int timeout,
    uint8_t *err
) {
    // 设置接收超时
    struct timeval tv = {
        .tv_sec = timeout / 1000,
        .tv_usec = (timeout % 1000) * 1000
    };
    setsockopt(udp_socket, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    
    // 接收数据
    int received = recvfrom(udp_socket, buf, len, 0, NULL, NULL);
    return (received > 0) ? received : 0;
}
```

---

## 附录

### A. 关键数据结构

#### 通用配置结构

```c
typedef struct {
    // WiFi配置
    char wifi_ssid[32];
    char wifi_password[64];
    wifi_auth_mode_t wifi_auth;
    
    // ROS配置
    char ros_agent_ip[16];
    uint16_t ros_agent_port;
    char ros_node_name[32];
    char ros_namespace[32];
    uint8_t ros_domain_id;
    
    // 节点配置
    uint8_t sensor_sampling_rate;
    uint8_t log_level;
} node_config_t;
```

#### 诊断数据结构

```c
typedef struct {
    uint8_t level;  // OK/WARN/ERROR/STALE
    char name[32];
    char message[128];
    char hardware_id[18];  // MAC地址
    struct {
        char key[32];
        char value[64];
    } values[MAX_DIAGNOSTIC_KV];
    size_t value_count;
} diagnostic_data_t;
```

### B. 错误处理策略

```c
// 错误代码定义
#define ERR_WIFI_CONNECT_FAILED    0x1001
#define ERR_ROS_AGENT_TIMEOUT      0x1002
#define ERR_SENSOR_READ_FAILED     0x1003
#define ERR_ACTUATOR_FAULT         0x1004

// 错误处理
esp_err_t handle_error(uint16_t error_code) {
    switch (error_code) {
        case ERR_WIFI_CONNECT_FAILED:
            wifi_reconnect();
            break;
        case ERR_ROS_AGENT_TIMEOUT:
            ros_reconnect();
            break;
        case ERR_SENSOR_READ_FAILED:
            sensor_reset();
            break;
        default:
            ESP_LOGE(TAG, "Unknown error: 0x%04X", error_code);
    }
    return ESP_OK;
}
```

### C. 性能优化建议

| 优化项 | 策略 | 效果 |
|--------|------|------|
| **内存优化** | 使用静态分配代替动态分配 | 减少碎片 |
| **CPU优化** | 合理设置任务优先级 | 避免饥饿 |
| **通信优化** | 批量发送ROS消息 | 降低开销 |
| **功耗优化** | 动态调频+WiFi省电 | 延长续航 |

---

**文档结束**

**编写人**：软件架构师  
**审核人**：技术负责人  
**版本**：v1.0.0  
**日期**：2025-10-23