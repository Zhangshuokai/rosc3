# 建筑喷涂施工机器人测试规范

## 文档信息

| 项目 | 内容 |
|------|------|
| **文档标题** | 测试规范文档 |
| **文档版本** | v1.0.0 |
| **编制日期** | 2025-10-23 |
| **测试框架** | Unity + CMock |
| **适用范围** | 所有ESP32-C3节点代码 |
| **覆盖率要求** | 核心模块≥80% |

---

## 目录

- [1. 测试策略](#1-测试策略)
- [2. 单元测试规范](#2-单元测试规范)
- [3. 集成测试规范](#3-集成测试规范)
- [4. 硬件在环测试](#4-硬件在环测试)
- [5. 性能测试](#5-性能测试)
- [6. 测试工具和框架](#6-测试工具和框架)
- [7. 测试覆盖率要求](#7-测试覆盖率要求)
- [8. 测试文档规范](#8-测试文档规范)

---

## 1. 测试策略

### 1.1 测试金字塔

```
        ┌─────────────┐
        │   手动测试   │  10%  - 端到端验证
        ├─────────────┤
        │  集成测试    │  30%  - 模块间接口
        ├─────────────┤
        │  单元测试    │  60%  - 函数级测试
        └─────────────┘
```

### 1.2 测试分类

| 测试类型 | 比例 | 执行频率 | 执行环境 | 目的 |
|---------|------|---------|---------|------|
| **单元测试** | 60% | 每次提交 | PC/CI | 验证函数逻辑正确性 |
| **集成测试** | 30% | 每日构建 | 目标硬件 | 验证模块间接口 |
| **系统测试** | 8% | 每周 | 实际系统 | 验证整体功能 |
| **验收测试** | 2% | 发布前 | 现场环境 | 验证需求满足 |

### 1.3 测试策略矩阵

| 模块 | 单元测试 | 集成测试 | 硬件测试 | 优先级 |
|------|---------|---------|---------|--------|
| WiFi管理 | ✅ | ✅ | ✅ | P0 |
| ROS通信 | ✅ | ✅ | ✅ | P0 |
| 底盘控制 | ✅ | ✅ | ✅ | P0 |
| 传感器驱动 | ✅ | ⚠️ | ✅ | P1 |
| OLED显示 | ⚠️ | ⚠️ | ✅ | P2 |

---

## 2. 单元测试规范

### 2.1 单元测试框架

**使用Unity测试框架**：

```c
// test/unit/test_chassis_control.c
#include "unity.h"
#include "chassis_control.h"

// 每个测试用例前执行
void setUp(void) {
    chassis_init();
}

// 每个测试用例后执行
void tearDown(void) {
    chassis_deinit();
}

// 测试用例
void test_chassis_set_velocity_valid_input(void) {
    // Arrange（准备）
    chassis_cmd_vel_t cmd = {
        .linear_velocity = 0.5f,
        .angular_velocity = 0.2f
    };
    
    // Act（执行）
    esp_err_t ret = chassis_set_velocity(&cmd);
    
    // Assert（断言）
    TEST_ASSERT_EQUAL(ESP_OK, ret);
}

void test_chassis_set_velocity_invalid_input(void) {
    chassis_cmd_vel_t cmd = {
        .linear_velocity = 2.0f,  // 超过最大值
        .angular_velocity = 0.0f
    };
    
    esp_err_t ret = chassis_set_velocity(&cmd);
    
    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_ARG, ret);
}

// 主测试函数
int main(void) {
    UNITY_BEGIN();
    
    RUN_TEST(test_chassis_set_velocity_valid_input);
    RUN_TEST(test_chassis_set_velocity_invalid_input);
    
    return UNITY_END();
}
```

### 2.2 测试命名规范

```c
// 命名格式：test_<模块>_<函数>_<场景>

// ✅ 好的命名
void test_wifi_manager_connect_success(void);
void test_wifi_manager_connect_timeout(void);
void test_wifi_manager_connect_wrong_password(void);

void test_chassis_odometry_update_forward_motion(void);
void test_chassis_odometry_update_rotation(void);
void test_chassis_odometry_update_encoder_overflow(void);

// ❌ 不好的命名
void test1(void);
void test_wifi(void);
void test_ok(void);
```

### 2.3 AAA模式（Arrange-Act-Assert）

```c
void test_example(void) {
    // Arrange（准备）- 设置测试数据和环境
    sensor_config_t config = {
        .sampling_rate = 50,
        .filter_enable = true
    };
    sensor_t sensor;
    sensor_init(&sensor, &config);
    
    // Act（执行）- 调用被测试的函数
    float value = sensor_read(&sensor);
    
    // Assert（断言）- 验证结果
    TEST_ASSERT_FLOAT_WITHIN(0.1f, 25.0f, value);
    
    // Cleanup（清理）
    sensor_deinit(&sensor);
}
```

### 2.4 Mock对象使用

```c
// 使用CMock模拟I2C驱动

// test/unit/test_bme280_driver.c
#include "unity.h"
#include "bme280_driver.h"
#include "mock_i2c_bus.h"  // CMock生成的mock

void test_bme280_read_temperature(void) {
    // 设置mock期望
    i2c_read_bytes_ExpectAndReturn(BME280_ADDR, REG_TEMP, 
                                    buffer, 3, ESP_OK);
    i2c_read_bytes_ReturnArrayThruPtr_data(temp_data, 3);
    
    // 执行测试
    float temp;
    esp_err_t ret = bme280_read_temperature(&temp);
    
    // 验证
    TEST_ASSERT_EQUAL(ESP_OK, ret);
    TEST_ASSERT_FLOAT_WITHIN(0.1f, 25.0f, temp);
}
```

### 2.5 边界条件测试

```c
void test_boundary_conditions(void) {
    // 测试最小值
    TEST_ASSERT_EQUAL(ESP_OK, func(0));
    
    // 测试最大值
    TEST_ASSERT_EQUAL(ESP_OK, func(MAX_VALUE));
    
    // 测试超出范围
    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_ARG, func(-1));
    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_ARG, func(MAX_VALUE + 1));
    
    // 测试NULL指针
    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_ARG, func(NULL));
    
    // 测试空字符串
    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_ARG, func(""));
}
```

---

## 3. 集成测试规范

### 3.1 模块间接口测试

```c
// test/integration/test_ros_comm_integration.c

void test_ros_publish_subscribe_integration(void) {
    // 1. 初始化WiFi
    wifi_manager_init(&wifi_config);
    wifi_manager_connect();
    
    // 2. 初始化ROS
    ros_comm_init(&ros_config);
    
    // 3. 创建发布者和订阅者
    rcl_publisher_t pub;
    rcl_subscription_t sub;
    ros_comm_create_publisher(&type_support, "/test", &pub);
    ros_comm_create_subscription(&type_support, "/test", callback, &sub);
    
    // 4. 发布消息
    test_msg_t msg = {.data = 42};
    ros_publish(&pub, &msg);
    
    // 5. 等待接收
    vTaskDelay(pdMS_TO_TICKS(100));
    
    // 6. 验证接收到的消息
    TEST_ASSERT_EQUAL(42, received_msg.data);
}
```

### 3.2 状态机测试

```c
void test_node_state_machine(void) {
    // 初始状态
    TEST_ASSERT_EQUAL(NODE_STATE_INIT, get_node_state());
    
    // 模拟WiFi连接成功
    simulate_wifi_connected();
    node_state_machine_update();
    TEST_ASSERT_EQUAL(NODE_STATE_WIFI_CONNECTED, get_node_state());
    
    // 模拟ROS连接成功
    simulate_ros_connected();
    node_state_machine_update();
    TEST_ASSERT_EQUAL(NODE_STATE_RUNNING, get_node_state());
    
    // 模拟WiFi断开
    simulate_wifi_disconnected();
    node_state_machine_update();
    TEST_ASSERT_EQUAL(NODE_STATE_ERROR, get_node_state());
}
```

### 3.3 多任务集成测试

```c
void test_multi_task_integration(void) {
    // 创建测试任务
    xTaskCreate(producer_task, "producer", 2048, NULL, 5, NULL);
    xTaskCreate(consumer_task, "consumer", 2048, NULL, 5, NULL);
    
    // 运行一段时间
    vTaskDelay(pdMS_TO_TICKS(1000));
    
    // 验证结果
    TEST_ASSERT_EQUAL(100, get_processed_count());
    TEST_ASSERT_EQUAL(0, get_error_count());
}
```

---

## 4. 硬件在环测试

### 4.1 传感器测试

```c
// test/hardware/test_bme280_hw.c

void test_bme280_read_real_data(void) {
    // 初始化真实硬件
    bme280_config_t config = {
        .i2c_addr = BME280_I2C_ADDR,
        .mode = BME280_MODE_NORMAL
    };
    TEST_ASSERT_EQUAL(ESP_OK, bme280_init(&config));
    
    // 读取真实数据
    float temp, pressure, humidity;
    TEST_ASSERT_EQUAL(ESP_OK, bme280_read_all(&temp, &pressure, &humidity));
    
    // 验证数据合理性
    TEST_ASSERT_TRUE(temp >= -20.0f && temp <= 60.0f);
    TEST_ASSERT_TRUE(pressure >= 80000.0f && pressure <= 110000.0f);
    TEST_ASSERT_TRUE(humidity >= 0.0f && humidity <= 100.0f);
    
    ESP_LOGI(TAG, "Temperature: %.2f°C", temp);
    ESP_LOGI(TAG, "Pressure: %.2fPa", pressure);
    ESP_LOGI(TAG, "Humidity: %.2f%%", humidity);
}
```

### 4.2 执行器测试

```c
void test_motor_control_hw(void) {
    // 初始化电机驱动
    motor_init();
    
    // 测试前进
    motor_set_speed(MOTOR_LEFT, 0.5f);
    motor_set_speed(MOTOR_RIGHT, 0.5f);
    vTaskDelay(pdMS_TO_TICKS(1000));
    
    // 读取编码器
    uint32_t enc_left = encoder_read_left();
    uint32_t enc_right = encoder_read_right();
    
    // 验证编码器有变化
    TEST_ASSERT_TRUE(enc_left > 0);
    TEST_ASSERT_TRUE(enc_right > 0);
    
    // 停止
    motor_stop();
}
```

### 4.3 WiFi连接测试

```c
void test_wifi_connection_hw(void) {
    wifi_config_t config = {
        .ssid = TEST_WIFI_SSID,
        .password = TEST_WIFI_PASSWORD,
        .auth_mode = WIFI_AUTH_WPA2_PSK
    };
    
    // 测试连接
    TEST_ASSERT_EQUAL(ESP_OK, wifi_manager_init(&config));
    TEST_ASSERT_EQUAL(ESP_OK, wifi_manager_connect());
    
    // 等待连接
    int retry = 0;
    while (!wifi_is_connected() && retry < 20) {
        vTaskDelay(pdMS_TO_TICKS(500));
        retry++;
    }
    
    // 验证连接成功
    TEST_ASSERT_TRUE(wifi_is_connected());
    
    // 获取IP地址
    wifi_status_t status;
    wifi_manager_get_status(&status);
    ESP_LOGI(TAG, "IP Address: " IPSTR, IP2STR(&status.ip_addr));
    TEST_ASSERT_TRUE(status.ip_addr.addr != 0);
}
```

---

## 5. 性能测试

### 5.1 响应时间测试

```c
void test_control_loop_latency(void) {
    uint32_t start, end, latency;
    uint32_t max_latency = 0;
    uint32_t sum_latency = 0;
    
    for (int i = 0; i < 100; i++) {
        start = esp_timer_get_time();
        
        // 执行控制循环
        control_loop_iteration();
        
        end = esp_timer_get_time();
        latency = end - start;
        
        sum_latency += latency;
        if (latency > max_latency) {
            max_latency = latency;
        }
    }
    
    uint32_t avg_latency = sum_latency / 100;
    
    ESP_LOGI(TAG, "Average latency: %lu us", avg_latency);
    ESP_LOGI(TAG, "Max latency: %lu us", max_latency);
    
    // 验证延迟要求
    TEST_ASSERT_TRUE(avg_latency < 20000);  // 平均<20ms
    TEST_ASSERT_TRUE(max_latency < 50000);  // 最大<50ms
}
```

### 5.2 吞吐量测试

```c
void test_ros_message_throughput(void) {
    uint32_t message_count = 0;
    uint32_t start_time = xTaskGetTickCount();
    
    // 发送消息1秒
    while ((xTaskGetTickCount() - start_time) < pdMS_TO_TICKS(1000)) {
        sensor_msg_t msg;
        ros_publish(&publisher, &msg);
        message_count++;
    }
    
    ESP_LOGI(TAG, "Messages sent: %lu/s", message_count);
    
    // 验证吞吐量
    TEST_ASSERT_TRUE(message_count >= 50);  // 至少50Hz
}
```

### 5.3 内存使用测试

```c
void test_memory_usage(void) {
    // 记录初始堆大小
    size_t initial_free = esp_get_free_heap_size();
    
    // 执行操作1000次
    for (int i = 0; i < 1000; i++) {
        perform_operation();
        vTaskDelay(pdMS_TO_TICKS(10));
    }
    
    // 记录最终堆大小
    size_t final_free = esp_get_free_heap_size();
    
    // 验证无内存泄漏
    int32_t leak = initial_free - final_free;
    ESP_LOGI(TAG, "Memory leak: %ld bytes", leak);
    
    TEST_ASSERT_TRUE(abs(leak) < 1024);  // 允许1KB误差
}
```

### 5.4 CPU占用测试

```c
void test_cpu_usage(void) {
    // 使用FreeRTOS运行时统计
    TaskStatus_t *task_array;
    uint32_t total_runtime;
    
    uxTaskGetSystemState(task_array, uxTaskGetNumberOfTasks(), &total_runtime);
    
    // 计算各任务CPU占用
    for (int i = 0; i < task_count; i++) {
        uint32_t percentage = 
            (task_array[i].ulRunTimeCounter * 100) / total_runtime;
        ESP_LOGI(TAG, "Task %s: %lu%%", 
                 task_array[i].pcTaskName, percentage);
    }
    
    // 验证总CPU占用<60%
    uint32_t idle_percentage = get_idle_task_percentage();
    TEST_ASSERT_TRUE(idle_percentage > 40);
}
```

---

## 6. 测试工具和框架

### 6.1 Unity测试框架

```bash
# 安装Unity
git clone https://github.com/ThrowTheSwitch/Unity.git lib/Unity

# 配置platformio.ini
[env:native_test]
platform = native
test_framework = unity
build_flags = -I lib/Unity/src
lib_deps = Unity
```

### 6.2 CMock

```bash
# 安装CMock
git clone https://github.com/ThrowTheSwitch/CMock.git lib/CMock

# 生成Mock文件
ruby lib/CMock/lib/cmock.rb src/drivers/i2c_bus.h
```

### 6.3 gcov代码覆盖率

```ini
# platformio.ini
[env:coverage]
platform = native
build_flags = 
    -fprofile-arcs
    -ftest-coverage
    -O0

# 运行测试并生成覆盖率报告
pio test -e coverage
gcovr -r . --html --html-details -o coverage.html
```

### 6.4 Cppcheck静态分析

```bash
# 运行静态分析
cppcheck --enable=all --inconclusive \
         --suppress=missingIncludeSystem \
         --xml --xml-version=2 \
         src/ 2> cppcheck.xml

# 生成报告
cppcheck-htmlreport --file=cppcheck.xml --report-dir=cppcheck_report
```

---

## 7. 测试覆盖率要求

### 7.1 覆盖率目标

| 模块类型 | 行覆盖率 | 分支覆盖率 | 优先级 |
|---------|---------|-----------|--------|
| **核心控制** | ≥80% | ≥70% | P0 |
| **通信模块** | ≥80% | ≥70% | P0 |
| **传感器驱动** | ≥70% | ≥60% | P1 |
| **工具函数** | ≥90% | ≥80% | P1 |
| **UI显示** | ≥50% | ≥40% | P2 |

### 7.2 覆盖率报告

```bash
# 生成覆盖率报告
pio test -e coverage

# 查看覆盖率摘要
gcovr -r .

# 生成HTML报告
gcovr -r . --html-details -o coverage/index.html

# 输出示例
------------------------------------------------------------------------------
GCC Code Coverage Report
Directory: .
------------------------------------------------------------------------------
File                          Lines    Exec  Cover   Missing
------------------------------------------------------------------------------
src/chassis_control.c           150     135   90%    45-48,89
src/wifi_manager.c              200     160   80%    
src/ros_comm.c                  180     144   80%    
------------------------------------------------------------------------------
TOTAL                           530     439   82.8%
```

### 7.3 未测试代码标记

```c
// 标记无法测试的代码
// LCOV_EXCL_START
void hardware_specific_code(void) {
    // 仅在特定硬件上执行
}
// LCOV_EXCL_STOP

// 标记单行无法测试
void func(void) {
    assert(ptr != NULL);  // LCOV_EXCL_LINE
}
```

---

## 8. 测试文档规范

### 8.1 测试计划

```markdown
# 底盘控制模块测试计划

## 测试目标
验证底盘控制模块的速度控制、里程计计算和PID闭环功能

## 测试范围
- 速度指令解析
- PID控制器
- 里程计计算
- 编码器读取

## 测试方法
- 单元测试：函数级测试
- 集成测试：与电机驱动集成
- 硬件测试：实际电机运行

## 测试环境
- 开发板：Adafruit QT Py ESP32-C3
- 电机：带编码器的减速电机×2
- 电源：12V 2A

## 测试用例
| ID | 测试项 | 预期结果 |
|----|--------|---------|
| TC001 | 设置有效速度 | 返回ESP_OK |
| TC002 | 设置超限速度 | 返回ESP_ERR_INVALID_ARG |
| TC003 | 里程计直线运动 | 误差<2% |
| TC004 | 里程计旋转运动 | 误差<5% |

## 通过标准
- 所有测试用例通过
- 代码覆盖率≥80%
- 无内存泄漏
```

### 8.2 测试用例

```markdown
# 测试用例：chassis_set_velocity

## 基本信息
- **ID**: TC001
- **优先级**: P0
- **类型**: 单元测试
- **模块**: chassis_control

## 前置条件
- 底盘已初始化
- PID控制器已配置

## 测试步骤
1. 准备速度指令：linear=0.5m/s, angular=0.2rad/s
2. 调用chassis_set_velocity()
3. 检查返回值

## 预期结果
- 返回ESP_OK
- 内部状态更新正确

## 实际结果
（测试执行后填写）

## 测试数据
```c
chassis_cmd_vel_t cmd = {
    .linear_velocity = 0.5f,
    .angular_velocity = 0.2f
};
```

## 备注
无
```

### 8.3 测试报告

```markdown
# 底盘控制模块测试报告

## 测试摘要
- **测试日期**: 2025-10-23
- **测试人员**: 张三
- **测试版本**: v1.0.0
- **测试环境**: ESP32-C3 + 电机×2

## 测试结果统计
| 项目 | 数量 | 百分比 |
|------|------|--------|
| 总用例数 | 25 | 100% |
| 通过 | 24 | 96% |
| 失败 | 1 | 4% |
| 阻塞 | 0 | 0% |

## 失败用例分析
### TC015: 编码器溢出处理
- **失败原因**: 编码器计数溢出时里程计计算错误
- **影响**: 长时间运行后里程计精度下降
- **解决方案**: 添加溢出检测和处理逻辑
- **状态**: 已修复，待回归测试

## 代码覆盖率
- 行覆盖率: 85%
- 分支覆盖率: 78%
- 函数覆盖率: 92%

## 性能测试结果
- 控制循环延迟: 平均15ms, 最大48ms ✅
- ROS消息发布频率: 52Hz ✅
- CPU占用率: 45% ✅
- 内存占用: 120KB ✅

## 结论
✅ 测试通过，允许发布

## 建议
1. 提高编码器溢出处理的测试覆盖
2. 增加长时间运行的稳定性测试
```

---

## 附录

### A. 测试自动化脚本

```bash
#!/bin/bash
# scripts/run_all_tests.sh

echo "=== 运行所有测试 ==="

# 1. 单元测试
echo "1. 运行单元测试..."
pio test -e native_test
if [ $? -ne 0 ]; then
    echo "❌ 单元测试失败"
    exit 1
fi

# 2. 生成覆盖率报告
echo "2. 生成覆盖率报告..."
gcovr -r . --html-details -o coverage/index.html

# 3. 静态分析
echo "3. 运行静态分析..."
cppcheck --enable=all src/

# 4. 硬件测试（可选）
read -p "运行硬件测试？(y/n) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    pio test -e esp32c3 --upload-port /dev/ttyUSB0
fi

echo "✅ 所有测试完成"
```

### B. CI/CD集成

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up PlatformIO
        run: |
          pip install platformio
          
      - name: Run unit tests
        run: pio test -e native_test
        
      - name: Generate coverage
        run: |
          gcovr -r . --xml -o coverage.xml
          
      - name: Upload coverage
        uses: codecov/codecov-action@v2
        with:
          files: ./coverage.xml
```

### C. 常见测试问题

| 问题 | 原因 | 解决方案 |
|------|------|---------|
| 测试不稳定 | 依赖硬件时序 | 使用Mock隔离硬件 |
| 覆盖率低 | 错误处理未测试 | 添加异常路径测试 |
| 测试太慢 | 真实硬件等待 | 分离单元测试和硬件测试 |
| 内存泄漏 | 未释放资源 | 使用valgrind检测 |

---

**文档结束**

**编写人**：测试工程师  
**审核人**：质量负责人  
**版本**：v1.0.0  
**日期**：2025-10-23