# 建筑喷涂施工机器人开发规范

## 文档信息

| 项目 | 内容 |
|------|------|
| **文档标题** | 开发规范文档 |
| **文档版本** | v1.0.0 |
| **编制日期** | 2025-10-23 |
| **编程语言** | C (C11标准) |
| **适用范围** | 所有ESP32-C3节点代码 |
| **强制执行** | 是 |

---

## 目录

- [1. C语言编码规范](#1-c语言编码规范)
- [2. 命名规范](#2-命名规范)
- [3. 代码格式规范](#3-代码格式规范)
- [4. 注释规范](#4-注释规范)
- [5. 错误处理规范](#5-错误处理规范)
- [6. 内存管理规范](#6-内存管理规范)
- [7. 并发编程规范](#7-并发编程规范)
- [8. 代码审查规范](#8-代码审查规范)

---

## 1. C语言编码规范

### 1.1 基本原则

| 原则 | 说明 | 强制性 |
|------|------|--------|
| **简洁清晰** | 代码易读比clever更重要 | ✅ 强制 |
| **一致性** | 遵循统一的编码风格 | ✅ 强制 |
| **安全性** | 避免未定义行为和缓冲区溢出 | ✅ 强制 |
| **可维护性** | 代码易于理解和修改 | ✅ 强制 |
| **性能** | 在保证可读性的前提下优化 | ⚠️ 建议 |

### 1.2 C语言标准

**使用C11标准**：

```c
// ✅ 推荐：使用C11特性
#include <stdatomic.h>
#include <stdalign.h>

// static_assert编译时检查
static_assert(sizeof(int) == 4, "int must be 4 bytes");

// _Generic类型泛型
#define max(a, b) _Generic((a), \
    int: max_int, \
    float: max_float \
)(a, b)
```

**禁止使用的特性**：

```c
// ❌ 禁止：变长数组（VLA）- 栈溢出风险
void func(int n) {
    int array[n];  // 禁止
}

// ✅ 推荐：使用固定大小或动态分配
void func(int n) {
    int array[MAX_SIZE];  // 固定大小
    // 或
    int *array = malloc(n * sizeof(int));  // 动态分配
    free(array);
}

// ❌ 禁止：goto语句（除了错误处理）
goto label;

// ✅ 允许：仅用于统一错误清理
esp_err_t func(void) {
    esp_err_t ret = ESP_OK;
    void *ptr = malloc(100);
    if (!ptr) {
        ret = ESP_ERR_NO_MEM;
        goto cleanup;
    }
    
    // ... 其他操作
    
cleanup:
    free(ptr);
    return ret;
}
```

### 1.3 头文件包含顺序

```c
/**
 * 标准包含顺序（从上到下）：
 * 1. 本模块头文件
 * 2. C标准库
 * 3. 系统头文件
 * 4. 第三方库
 * 5. 项目内头文件
 */

// 1. 本模块头文件（确保其自包含性）
#include "chassis_node.h"

// 2. C标准库
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

// 3. 系统头文件（ESP-IDF）
#include "esp_log.h"
#include "esp_err.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// 4. 第三方库
#include "lvgl.h"

// 5. 项目内头文件
#include "common/wifi_manager/wifi_manager.h"
#include "common/ros_comm/ros_comm.h"
#include "drivers/i2c_bus/i2c_bus.h"
```

---

## 2. 命名规范

### 2.1 通用命名规则

| 类型 | 规则 | 示例 | 说明 |
|------|------|------|------|
| **文件名** | 小写+下划线 | `chassis_control.c` | - |
| **函数名** | 小写+下划线 | `chassis_set_velocity()` | 动词开头 |
| **变量名** | 小写+下划线 | `motor_speed` | 名词 |
| **常量名** | 大写+下划线 | `MAX_SPEED` | 宏定义 |
| **类型名** | 小写+下划线+_t | `chassis_state_t` | 类型后缀 |
| **枚举值** | 大写+下划线 | `NODE_STATE_RUNNING` | - |
| **宏函数** | 大写+下划线 | `MIN(a, b)` | - |

### 2.2 函数命名

```c
// ✅ 好的命名：动词+名词
esp_err_t chassis_init(void);
esp_err_t chassis_set_velocity(float v);
float chassis_get_position(void);
void motor_start(void);
void motor_stop(void);
bool sensor_is_ready(void);

// ❌ 不好的命名
void chassis(void);        // 不清楚做什么
void process(void);        // 太泛化
void do_it(void);          // 无意义
void x(void);              // 无意义
```

**函数命名模式**：

```c
// 模式：<模块>_<动作>_<对象>()
wifi_manager_get_status()
ros_comm_create_publisher()
config_manager_save_to_nvs()

// 布尔函数：is_/has_/can_/should_
bool wifi_is_connected(void);
bool sensor_has_data(void);
bool motor_can_start(void);
```

### 2.3 变量命名

```c
// ✅ 好的命名：描述性
uint32_t encoder_count;
float target_velocity;
bool wifi_connected;
chassis_state_t current_state;

// ❌ 不好的命名
int x;                     // 无意义
int tmp;                   // 太泛化（除非真的是临时变量）
float v;                   // 太短
uint32_t cnt;              // 缩写不清晰

// ✅ 允许的简短命名（约定俗成）
int i, j, k;               // 循环计数器
esp_err_t ret;             // 返回值
void *ptr;                 // 指针
size_t len;                // 长度
```

**全局变量前缀**：

```c
// 全局变量使用g_前缀
static chassis_state_t g_chassis_state;
static bool g_is_initialized = false;

// 静态局部变量使用s_前缀
void func(void) {
    static int s_call_count = 0;
    s_call_count++;
}
```

### 2.4 类型命名

```c
// ✅ 结构体：小写+下划线+_t
typedef struct {
    float x;
    float y;
    float theta;
} pose_2d_t;

// ✅ 枚举：小写+下划线+_t
typedef enum {
    NODE_STATE_INIT,
    NODE_STATE_RUNNING,
    NODE_STATE_ERROR
} node_state_t;

// ✅ 联合体：小写+下划线+_t
typedef union {
    uint32_t value;
    struct {
        uint8_t byte0;
        uint8_t byte1;
        uint8_t byte2;
        uint8_t byte3;
    };
} register_32_t;

// ✅ 函数指针类型
typedef void (*event_callback_t)(void *arg);
```

### 2.5 宏命名

```c
// ✅ 常量宏：大写+下划线
#define MAX_SPEED_MPS       1.0f
#define BUFFER_SIZE         256
#define PI                  3.14159265f

// ✅ 函数宏：大写+下划线
#define MIN(a, b)           ((a) < (b) ? (a) : (b))
#define MAX(a, b)           ((a) > (b) ? (a) : (b))
#define ARRAY_SIZE(arr)     (sizeof(arr) / sizeof((arr)[0]))

// ⚠️ 注意：参数加括号，避免优先级问题
#define SQUARE(x)           ((x) * (x))  // ✅
#define SQUARE_BAD(x)       x * x        // ❌ 可能出错

// 示例：SQUARE_BAD(1+2) = 1+2*1+2 = 5（错误）
//       SQUARE(1+2) = ((1+2)*(1+2)) = 9（正确）
```

---

## 3. 代码格式规范

### 3.1 缩进和空格

```c
// 使用4个空格缩进（不使用Tab）
void func(void) {
    if (condition) {
        do_something();
    }
}

// 二元运算符两边加空格
int result = a + b;
bool flag = (x > 0) && (y < 10);

// 逗号后加空格
func(a, b, c);

// 函数名和括号之间不加空格
func();          // ✅
func ();         // ❌

// if/while/for和括号之间加空格
if (condition)   // ✅
if(condition)    // ❌
```

### 3.2 花括号风格

**使用K&R风格（推荐）**：

```c
// ✅ K&R风格
void func(void) {
    if (condition) {
        do_something();
    } else {
        do_other();
    }
}

// ❌ Allman风格（不推荐）
void func(void)
{
    if (condition)
    {
        do_something();
    }
}

// ⚠️ 单行语句也要加花括号
if (condition) {    // ✅
    action();
}

if (condition)      // ❌ 不推荐
    action();
```

### 3.3 行长度限制

```c
// 每行不超过100个字符

// ✅ 长行自动换行
esp_err_t chassis_set_velocity(
    float linear_velocity,
    float angular_velocity
) {
    // ...
}

// ✅ 长条件拆分
if (condition1 &&
    condition2 &&
    condition3) {
    // ...
}

// ✅ 长字符串拆分
const char *message = 
    "This is a very long message that needs to be "
    "split across multiple lines for readability.";
```

### 3.4 代码块分隔

```c
void app_main(void) {
    /*******************************************************************
     * 初始化阶段
     *******************************************************************/
    
    // WiFi初始化
    wifi_manager_init(&wifi_config);
    wifi_manager_connect();
    
    // ROS初始化
    ros_comm_init(&ros_config);
    
    /*******************************************************************
     * 任务创建
     *******************************************************************/
    
    // 创建控制任务
    xTaskCreate(control_task, "ctrl", STACK_SIZE, 
                NULL, PRIORITY, NULL);
    
    // 创建传感器任务
    xTaskCreate(sensor_task, "sensor", STACK_SIZE, 
                NULL, PRIORITY, NULL);
    
    /*******************************************************************
     * 主循环
     *******************************************************************/
    
    while (1) {
        // ...
    }
}
```

---

## 4. 注释规范

### 4.1 文件头注释

```c
/**
 * @file chassis_control.c
 * @brief 底盘控制模块实现
 * @version 1.0
 * @date 2025-10-23
 * @author 嵌入式开发组
 * 
 * 本文件实现差速底盘的速度控制、PID闭环和里程计计算
 * 
 * @copyright Copyright (c) 2025 Your Company
 */
```

### 4.2 函数注释（Doxygen风格）

```c
/**
 * @brief 设置底盘速度
 * 
 * 根据给定的线速度和角速度计算左右轮速度，并执行PID控制
 * 
 * @param[in] linear_velocity  线速度 (m/s)，范围 [-1.0, 1.0]
 * @param[in] angular_velocity 角速度 (rad/s)，范围 [-2.0, 2.0]
 * 
 * @return 
 *   - ESP_OK: 成功
 *   - ESP_ERR_INVALID_ARG: 参数超出范围
 *   - ESP_ERR_INVALID_STATE: 底盘未初始化
 * 
 * @note 此函数是线程安全的
 * @warning 调用前必须先调用 chassis_init()
 * 
 * @see chassis_init()
 * @see chassis_get_state()
 */
esp_err_t chassis_set_velocity(float linear_velocity, 
                                float angular_velocity);
```

### 4.3 代码块注释

```c
void control_loop(void) {
    // 步骤1: 读取传感器数据
    sensor_data_t data;
    sensor_read(&data);
    
    // 步骤2: 滤波处理
    // 使用一阶低通滤波器，截止频率10Hz
    float filtered = lpf_filter(&data.value, 10.0f);
    
    // 步骤3: PID控制
    // Kp=1.0, Ki=0.1, Kd=0.01
    float output = pid_compute(&pid_ctrl, target, filtered);
    
    // 步骤4: 输出到执行器
    actuator_set_output(output);
}
```

### 4.4 TODO/FIXME/XXX标记

```c
// TODO: 实现自动校准功能
// FIXME: 修复编码器计数溢出问题
// XXX: 此处算法需要优化，性能不佳
// HACK: 临时解决方案，需要重构

void func(void) {
    // TODO(张三): 添加参数有效性检查
    // 预计完成时间: 2025-11-01
    
    // FIXME: 当速度为0时会除零
    float result = distance / speed;
}
```

### 4.5 不必要的注释（避免）

```c
// ❌ 不必要：描述显而易见的事
i++;  // 增加i

// ❌ 不必要：重复函数名
// 设置速度
void set_velocity(float v);

// ✅ 必要：解释为什么
// 延迟100ms等待传感器稳定
vTaskDelay(pdMS_TO_TICKS(100));

// ✅ 必要：解释复杂算法
// 使用卡尔曼滤波融合IMU和里程计数据
float fused = kalman_filter(imu_data, odom_data);
```

---

## 5. 错误处理规范

### 5.1 统一使用esp_err_t

```c
// ✅ 推荐：使用ESP-IDF标准错误码
esp_err_t func(void) {
    if (error_condition) {
        return ESP_ERR_INVALID_ARG;
    }
    return ESP_OK;
}

// 调用时检查
esp_err_t ret = func();
if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Function failed: %s", esp_err_to_name(ret));
    return ret;
}

// 或使用宏
ESP_ERROR_CHECK(func());
```

### 5.2 错误传播

```c
// ✅ 好的错误传播
esp_err_t high_level_func(void) {
    esp_err_t ret;
    
    ret = low_level_func1();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Step 1 failed");
        return ret;  // 传播错误
    }
    
    ret = low_level_func2();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Step 2 failed");
        return ret;
    }
    
    return ESP_OK;
}
```

### 5.3 资源清理

```c
// ✅ 推荐：使用goto统一清理
esp_err_t func(void) {
    esp_err_t ret = ESP_OK;
    void *buffer = NULL;
    FILE *file = NULL;
    
    buffer = malloc(1024);
    if (!buffer) {
        ret = ESP_ERR_NO_MEM;
        goto cleanup;
    }
    
    file = fopen("data.txt", "r");
    if (!file) {
        ret = ESP_ERR_NOT_FOUND;
        goto cleanup;
    }
    
    // ... 正常操作
    
cleanup:
    if (file) fclose(file);
    if (buffer) free(buffer);
    return ret;
}
```

### 5.4 断言使用

```c
#include <assert.h>

void func(int *ptr, size_t len) {
    // 使用断言检查不应该发生的条件（调试用）
    assert(ptr != NULL);
    assert(len > 0);
    
    // 使用运行时检查处理可能的错误
    if (ptr == NULL || len == 0) {
        ESP_LOGE(TAG, "Invalid parameters");
        return;
    }
}

// ESP-IDF特定断言
ESP_ERROR_CHECK(wifi_init());  // 错误时中止
configASSERT(ptr != NULL);     // FreeRTOS断言
```

---

## 6. 内存管理规范

### 6.1 动态分配原则

```c
// ⚠️ 原则：嵌入式系统优先使用静态分配

// ✅ 推荐：静态分配
static uint8_t buffer[1024];
static task_context_t task_ctx;

// ⚠️ 谨慎：动态分配（仅必要时）
void *ptr = malloc(size);
if (ptr == NULL) {
    ESP_LOGE(TAG, "Malloc failed");
    return ESP_ERR_NO_MEM;
}
// 使用后必须释放
free(ptr);
```

### 6.2 内存泄漏预防

```c
// ❌ 内存泄漏示例
void bad_func(void) {
    char *buffer = malloc(100);
    if (error_condition) {
        return;  // 泄漏！未释放buffer
    }
    free(buffer);
}

// ✅ 正确做法
void good_func(void) {
    char *buffer = malloc(100);
    if (buffer == NULL) {
        return;
    }
    
    if (error_condition) {
        free(buffer);
        return;  // 正确清理
    }
    
    // ... 使用buffer
    
    free(buffer);
}
```

### 6.3 栈使用注意

```c
// ❌ 危险：大数组放在栈上
void bad_func(void) {
    uint8_t large_buffer[10240];  // 10KB栈空间！
}

// ✅ 推荐：使用静态或动态分配
static uint8_t g_large_buffer[10240];  // 静态

void good_func(void) {
    uint8_t *buffer = malloc(10240);  // 动态
    // ... 使用
    free(buffer);
}
```

### 6.4 字符串处理安全

```c
// ❌ 危险：不安全的字符串操作
char dest[10];
strcpy(dest, source);  // 可能溢出
sprintf(dest, "%s", source);  // 可能溢出

// ✅ 安全：使用带长度限制的函数
char dest[10];
strncpy(dest, source, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';  // 确保NULL结尾

snprintf(dest, sizeof(dest), "%s", source);

// ✅ ESP-IDF提供的安全函数
strlcpy(dest, source, sizeof(dest));
```

---

## 7. 并发编程规范

### 7.1 任务间通信

```c
// ✅ 推荐：使用FreeRTOS队列
QueueHandle_t data_queue;

// 创建队列
data_queue = xQueueCreate(10, sizeof(sensor_data_t));

// 生产者
sensor_data_t data;
if (xQueueSend(data_queue, &data, pdMS_TO_TICKS(100)) != pdTRUE) {
    ESP_LOGW(TAG, "Queue full");
}

// 消费者
sensor_data_t data;
if (xQueueReceive(data_queue, &data, pdMS_TO_TICKS(100)) == pdTRUE) {
    process_data(&data);
}
```

### 7.2 互斥访问

```c
// ✅ 使用互斥锁保护共享资源
static SemaphoreHandle_t state_mutex;
static chassis_state_t g_state;

void init(void) {
    state_mutex = xSemaphoreCreateMutex();
}

void update_state(float new_value) {
    // 获取锁
    if (xSemaphoreTake(state_mutex, pdMS_TO_TICKS(100)) == pdTRUE) {
        g_state.value = new_value;  // 临界区
        xSemaphoreGive(state_mutex);  // 释放锁
    } else {
        ESP_LOGE(TAG, "Failed to acquire mutex");
    }
}

chassis_state_t get_state(void) {
    chassis_state_t state_copy;
    if (xSemaphoreTake(state_mutex, pdMS_TO_TICKS(100)) == pdTRUE) {
        state_copy = g_state;  // 复制
        xSemaphoreGive(state_mutex);
    }
    return state_copy;
}
```

### 7.3 避免死锁

```c
// ❌ 可能死锁：不同顺序获取锁
// 任务A
xSemaphoreTake(mutex1, portMAX_DELAY);
xSemaphoreTake(mutex2, portMAX_DELAY);

// 任务B
xSemaphoreTake(mutex2, portMAX_DELAY);  // 死锁！
xSemaphoreTake(mutex1, portMAX_DELAY);

// ✅ 避免死锁：统一顺序获取锁
// 所有任务都按 mutex1 -> mutex2 顺序
xSemaphoreTake(mutex1, portMAX_DELAY);
xSemaphoreTake(mutex2, portMAX_DELAY);
// ... 使用
xSemaphoreGive(mutex2);
xSemaphoreGive(mutex1);
```

### 7.4 中断安全

```c
// ✅ 中断服务例程（ISR）
static QueueHandle_t isr_queue;

void IRAM_ATTR gpio_isr_handler(void *arg) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    uint32_t event = 1;
    
    // 使用FromISR版本的API
    xQueueSendFromISR(isr_queue, &event, &xHigherPriorityTaskWoken);
    
    // 触发任务切换
    if (xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
}

// ❌ 禁止在ISR中：
// - 调用阻塞API（xQueueSend、vTaskDelay等）
// - 调用malloc/free
// - 执行耗时操作
// - 调用printf（ESP_LOGI等）
```

---

## 8. 代码审查规范

### 8.1 审查清单

#### 功能性

- [ ] 代码实现了需求的功能
- [ ] 边界条件处理正确
- [ ] 错误处理完整
- [ ] 无逻辑错误

#### 代码质量

- [ ] 命名清晰一致
- [ ] 注释充分准确
- [ ] 无重复代码
- [ ] 复杂度合理（单函数<50行）

#### 安全性

- [ ] 无缓冲区溢出风险
- [ ] 指针使用安全
- [ ] 无内存泄漏
- [ ] 并发访问安全

#### 性能

- [ ] 无明显性能问题
- [ ] 内存使用合理
- [ ] CPU占用可接受

#### 可维护性

- [ ] 代码结构清晰
- [ ] 模块化合理
- [ ] 易于测试

### 8.2 审查流程

```
1. 提交Pull Request
   ↓
2. 自动化检查（编译、静态分析）
   ↓
3. 同行审查（至少1人）
   ↓
4. 修改反馈
   ↓
5. 再次审查
   ↓
6. 批准合并
```

### 8.3 审查意见模板

```markdown
## 审查意见

**总体评价**：✅ 批准 / ⚠️ 需要修改 / ❌ 拒绝

### 主要问题
1. [文件名:行号] 问题描述
   - 建议：修改建议

### 次要问题（建议）
1. [文件名:行号] 建议描述

### 优点
- 代码清晰
- 错误处理完善
```

---

## 附录

### A. 代码格式化工具

#### clang-format配置

```yaml
# .clang-format
BasedOnStyle: Google
IndentWidth: 4
ColumnLimit: 100
AllowShortFunctionsOnASingleLine: Empty
AllowShortIfStatementsOnASingleLine: Never
PointerAlignment: Right
```

#### 使用方式

```bash
# 格式化单个文件
clang-format -i src/chassis_node.c

# 格式化整个目录
find src/ -name "*.c" -o -name "*.h" | xargs clang-format -i
```

### B. 静态分析工具

```bash
# cppcheck
cppcheck --enable=all --suppress=missingIncludeSystem src/

# ESP-IDF自带的检查
idf.py check

# clang-tidy
clang-tidy src/chassis_node.c -- -Iinclude
```

### C. 常见错误示例

```c
// ❌ 错误1：未初始化变量
int value;
if (value > 0) { }  // 未定义行为

// ✅ 正确
int value = 0;

// ❌ 错误2：数组越界
int arr[10];
arr[10] = 5;  // 越界

// ✅ 正确
if (index < ARRAY_SIZE(arr)) {
    arr[index] = 5;
}

// ❌ 错误3：悬空指针
int *ptr = malloc(sizeof(int));
free(ptr);
*ptr = 5;  // 悬空指针

// ✅ 正确
int *ptr = malloc(sizeof(int));
*ptr = 5;
free(ptr);
ptr = NULL;
```

### D. 性能优化技巧

```c
// 1. 避免重复计算
// ❌
for (int i = 0; i < strlen(str); i++) { }

// ✅
size_t len = strlen(str);
for (size_t i = 0; i < len; i++) { }

// 2. 使用const优化
void process(const uint8_t *data, size_t len) {
    // 编译器知道data不会被修改，可以优化
}

// 3. 位操作优化
// ❌
value = value / 2;
value = value * 4;

// ✅
value = value >> 1;  // 除以2
value = value << 2;  // 乘以4

// 4. 内联小函数
static inline int square(int x) {
    return x * x;
}
```

---

**文档结束**

**编写人**：开发规范制定组  
**审核人**：技术负责人  
**版本**：v1.0.0  
**日期**：2025-10-23  
**强制执行日期**：2025-11-01